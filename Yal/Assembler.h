#pragma once

namespace Yal
{
	static constexpr size_t KB = 1024;
	static constexpr size_t MB = KB * KB;

	enum InstructionCode : uint8_t
	{
		INSTR_CODE_SP_ADD,
		INSTR_CODE_SP_SUB,

		INSTR_CODE_LOAD_EFFECTIVE_ADDRESS,
		INSTR_CODE_LOAD_CODE_ADDRESS,
		INSTR_CODE_LOAD_IMMEDIATE,
		INSTR_CODE_FLOAT_LOAD_IMMEDIATE,
		INSTR_CODE_DOUBLE_LOAD_IMMEDIATE,
		INSTR_CODE_LOAD,
		INSTR_CODE_LOAD_ADDRESS,
		INSTR_CODE_STORE,
		INSTR_CODE_STORE_ADDRESS,

		INSTR_CODE_PUSH,
		INSTR_CODE_POP,

		INSTR_CODE_MOVE,
		INSTR_CODE_AND,
		INSTR_CODE_OR,
		INSTR_CODE_XOR,
		INSTR_CODE_COMPLEMENT,

		INSTR_CODE_LOGICAL_AND,
		INSTR_CODE_LOGICAL_OR,
		INSTR_CODE_LOGICAL_XOR,
		INSTR_CODE_LOGICAL_NOT,

		INSTR_CODE_COMPARE_EQUAL,
		INSTR_CODE_COMPARE_LESS_THAN,
		INSTR_CODE_COMPARE_LESS_EQUAL,
		INSTR_CODE_COMPARE_GREATER_THAN,
		INSTR_CODE_COMPARE_GREATER_EQUAL,

		INSTR_CODE_FLOAT_COMPARE_EQUAL,
		INSTR_CODE_FLOAT_COMPARE_LESS_THAN,
		INSTR_CODE_FLOAT_COMPARE_LESS_EQUAL,
		INSTR_CODE_FLOAT_COMPARE_GREATER_THAN,
		INSTR_CODE_FLOAT_COMPARE_GREATER_EQUAL,

		INSTR_CODE_DOUBLE_COMPARE_EQUAL,
		INSTR_CODE_DOUBLE_COMPARE_LESS_THAN,
		INSTR_CODE_DOUBLE_COMPARE_LESS_EQUAL,
		INSTR_CODE_DOUBLE_COMPARE_GREATER_THAN,
		INSTR_CODE_DOUBLE_COMPARE_GREATER_EQUAL,

		INSTR_CODE_JUMP,
		INSTR_CODE_JUMP_IF_TRUE,

		INSTR_CODE_CALL,
		INSTR_CODE_CALL_INDIRECT,
		INSTR_CODE_CALL_NATIVE,
		INSTR_CODE_RETURN,

		INSTR_CODE_ADD,
		INSTR_CODE_SUBTRACT,
		INSTR_CODE_INCREMENT,
		INSTR_CODE_DECREMENT,
		INSTR_CODE_MULTIPLY,
		INSTR_CODE_DIVIDE,
		INSTR_CODE_ABSOLUTE,
		INSTR_CODE_NEGATE,
		INSTR_CODE_SHIFT_RIGHT,
		INSTR_CODE_SHIFT_LEFT,
		INSTR_CODE_CAST_TO_INTEGER,

		INSTR_CODE_FLOAT_ADD,
		INSTR_CODE_FLOAT_SUBTRACT,
		INSTR_CODE_FLOAT_MULTIPLY,
		INSTR_CODE_FLOAT_DIVIDE,
		INSTR_CODE_FLOAT_ABSOLUTE,
		INSTR_CODE_FLOAT_NEGATE,
		INSTR_CODE_FLOAT_SQRT,
		INSTR_CODE_FLOAT_COS,
		INSTR_CODE_FLOAT_SIN,
		INSTR_CODE_FLOAT_RND,
		INSTR_CODE_FLOAT_CAST,

		INSTR_CODE_DOUBLE_ADD,
		INSTR_CODE_DOUBLE_SUBTRACT,
		INSTR_CODE_DOUBLE_MULTIPLY,
		INSTR_CODE_DOUBLE_DIVIDE,
		INSTR_CODE_DOUBLE_ABSOLUTE,
		INSTR_CODE_DOUBLE_NEGATE,
		INSTR_CODE_DOUBLE_SQRT,
		INSTR_CODE_DOUBLE_COS,
		INSTR_CODE_DOUBLE_SIN,
		INSTR_CODE_DOUBLE_RND,
		INSTR_CODE_DOUBLE_CAST,

		INSTR_CODE_COUNT,
		INSTR_CODE_INVALID = INSTR_CODE_COUNT,
	};

	enum RegisterType : uint8_t
	{
		REGISTER_TYPE_BYTE,
		REGISTER_TYPE_UNSIGNED_BYTE,
		REGISTER_TYPE_WORD,
		REGISTER_TYPE_UNSIGNED_WORD,
		REGISTER_TYPE_DWORD,
		REGISTER_TYPE_UNSIGNED_DWORD,
		REGISTER_TYPE_NATIVE,
		REGISTER_TYPE_UNSIGNED_NATIVE,
		REGISTER_TYPE_FLOAT,
		REGISTER_TYPE_DOUBLE,
		REGISTER_TYPE_INVALID
	};

	using NameToAddressMap = std::unordered_map< std::string, int >;

	namespace Assembler
	{
		struct Context
		{
			using AddressToNameMap = std::unordered_map< int, std::string >;
			using LabelCall = std::tuple< std::string, size_t >;

			std::string				source;
			std::vector< uint8_t >	byteCode;
			std::vector< uint8_t >	data;
			NameToAddressMap		variables;
			NameToAddressMap		labels;
			std::vector< LabelCall > deferredLabelResolutions;
		};

		void Assemble( Context &context );
		void Disassemble( const Context &context, std::string &text );
	}
}
